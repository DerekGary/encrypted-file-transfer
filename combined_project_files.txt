### File: ./combine_project_files.py

import os
import sys

def combine_project_files(root_dir, output_file):
    print(f"Combining project files from {root_dir} into {output_file}")
    file_count = 0  # Counter for the number of files processed
    excluded_dirs = {'node_modules', 'venv', '__pycache__', 'build'}  # Directories to exclude
    allowed_extensions = (".py", ".conf", ".yml", ".html", ".js", ".css")  # Allowed file extensions

    with open(output_file, "w", encoding='utf-8') as outfile:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude specified directories
            dirnames[:] = [d for d in dirnames if d not in excluded_dirs]

            for filename in filenames:
                if filename.endswith(allowed_extensions):
                    filepath = os.path.join(dirpath, filename)
                    print(f"Processing file: {filepath}")  # Diagnostic print
                    try:
                        with open(filepath, "r", encoding='utf-8') as infile:
                            outfile.write(f"### File: {filepath}\n\n")
                            outfile.write(infile.read())
                            outfile.write("\n\n")
                            file_count += 1
                    except IOError as e:
                        print(f"Error opening or reading file {filepath}: {e}")

    if file_count == 0:
        print("No files were processed. Please check your directory path and file extensions.")
    else:
        print(f"Successfully processed {file_count} files.")

if __name__ == "__main__":
    if len(sys.argv) > 2:
        root_dir = sys.argv[1]  # Use the first command-line argument as the root directory
        output_file = sys.argv[2]  # Use the second command-line argument as the output file
    else:
        print("Usage: python script.py <root_dir> <output_file>")
        sys.exit(1)

    combine_project_files(root_dir, output_file)


### File: ./default.conf

# encrypted-file-transfer/default.conf
# This is the default configuration file for the Nginx server
# It is used to specify the server configuration and routing rules
# for the frontend and backend services.

resolver 172.30.0.2 valid=10s;
server {
    listen 80;
    server_name localhost; # Replace with actual domain or IP after instance creation

    # Serve static files directly
    location / {
        root /usr/share/nginx/html;
        index index.html index.html;
        try_files $uri $uri/ /index.html;
    }

    # Proxy API requests to the backend
    location /api/ {
        # proxy_pass should be setup such that AWS Service Connect Services on ECS can be used
        proxy_pass http://backend:8000/;
        proxy_http_version 1.1;

        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $server_name;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Important: This ensures the URI is passed correctly
        proxy_redirect off;

        # Add CORS headers
        add_header 'Access-Control-Allow-Origin' '*'; # Replace this with the appropriate frontend domain when possible
        add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, PATCH, DELETE';
        add_header 'Access-Control-Allow-Headers' 'Content-Type, Authorization';
    }

    # Add headers for security enhancements
    add_header X-Frame-Options "DENY";
    add_header X-Content-Type-Options "nosniff";
    add_header Referrer-Policy "same-origin";
    add_header Cross-Origin-Opener-Policy "same-origin";
}

### File: ./docker-compose.yml

version: '3.8'

services:
  frontend:
    build:
      context: .
      dockerfile: Dockerfile  # Pointing to your NGINX Dockerfile
    ports:
      - "80:80"
    depends_on:
      - backend

  backend:
    build:
      context: ./backend
    command: gunicorn wsgi:application --bind 0.0.0.0:8000
    ports:
      - "8000:8000"
    environment:
      - DB_HOST=testdb-1.cxmtczwiy4gj.us-east-2.rds.amazonaws.com
      - DB_NAME=testdb-1
      - DB_USER=postgres
      - DB_PASSWORD=b%Ki$M^miLsr8bEJmKNd
      - DB_PORT=5432

# version: '3.8'

# services:
#   frontend:
#     build:
#       context: .
#       dockerfile: Dockerfile  # Pointing to your NGINX Dockerfile
#     ports:
#       - "80:80"
#     depends_on:
#       - backend

#   backend:
#     build:
#       context: ./backend
#     command: gunicorn wsgi:application --bind 0.0.0.0:8000
#     volumes:
#       - ./backend:/app
#     ports:
#       - "8000:8000"
#     environment:
#       - DB_HOST=db
#       - DB_NAME=myprojectdb
#       - DB_USER=derek
#       - DB_PASSWORD=postgres
#       - DB_PORT=5432
#     depends_on:
#       - db

#   db:
#     image: postgres:latest
#     environment:
#       POSTGRES_DB: myprojectdb
#       POSTGRES_USER: derek
#       POSTGRES_PASSWORD: postgres
#     ports:
#       - "5432:5432"
#     volumes:
#       - postgres_data:/var/lib/postgresql/data

# volumes:
#   postgres_data:


### File: ./backend/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"


### File: ./backend/asgi.py

"""
ASGI config for backend project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings")

application = get_asgi_application()


### File: ./backend/manage.py

#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()


### File: ./backend/settings.py

# encrypted-file-transfer/backend/settings.py
"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 5.0.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
import os
import logging

# Assuming all backend Django files are in /app
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-d(7j9=&*)w%-m4bj!u9x3f68!zp58)px16+du#6a(r^!3(#h_e"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']

# I hate cors... so I'm just going to allow all origins for now.
CORS_ORIGIN_ALLOW_ALL = True

CSRF_TRUSTED_ORIGINS = [
    'http://localhost:3000', 
    'http://127.0.0.1:3000', 
    'http://127.0.0.1:8000', 
    'http://localhost',
]

# What's the difference between CSRF_TRUSTED_ORIGINS and CORS_ALLOWED_ORIGINS?
# CSRF_TRUSTED_ORIGINS is used to specify which origins are allowed to send
# cross-site requests. This is important for security reasons, as it helps
# prevent cross-site request forgery (CSRF) attacks. If you're using Django's
# CSRF protection middleware, you'll need to specify the origins that are
# allowed to send requests to your site. This is done by setting the
# CSRF_TRUSTED_ORIGINS setting in your Django settings file.
#
# CORS_ALLOWED_ORIGINS, on the other hand, is used to specify which origins
# are allowed to make cross-origin requests to your site. This is important
# for allowing requests from different domains, such as when you're building
# a frontend application that needs to make requests to a backend API. If you're
# using Django's CORS middleware, you'll need to specify the origins that are
# allowed to make requests to your site. This is done by setting the
# CORS_ALLOWED_ORIGINS setting in your Django settings file.
CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',
    'http://127.0.0.1:3000',
    'http://127.0.0.1:8000',
    'http://localhost:3000',
    'http://localhost',
]


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "core",
    "corsheaders",
]

MIDDLEWARE = [
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.TokenAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    )
}

ROOT_URLCONF = "urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

# Test Db:
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myprojectdb',
        'USER': 'derek',
        'PASSWORD': 'postgres',
        'HOST': 'db',
        'PORT': '5432',
    }
}

# Production Db:
# DATABASES = {
#     "default": {
#         "ENGINE": "django.db.backends.postgresql",
#         "NAME": os.environ.get('DB_NAME', 'testdb-1'),  # Default value is 'myproject-db'
#         "USER": os.environ.get('DB_USER', 'postgres'),  # Default value is 'postgres'
#         "PASSWORD": os.environ.get('DB_PASSWORD', 'b%Ki$M^miLsr8bEJmKNd'), 
#         "HOST": os.environ.get('DB_HOST', 'testdb-1.cxmtczwiy4gj.us-east-2.rds.amazonaws.com'),
#         "PORT": os.environ.get('DB_PORT', '5432'),  # Default value is '5432'
#     }
# }


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True

# Static URL is only used for development and not for
# production, ie serving our React app using Nginx.
STATIC_URL = '/static/'

# Directory where Django will store collected static files
# Adjust if necessary to match your desired path for static files

# REACT_APP_DIR isn't needed since we're serving our React app using Nginx.
# REACT_APP_DIR is a variable that points to the build directory
# of our React app. It's used in cases whenever you'd want your
# backend to serve the frontend as well. In this case, we're
# offloading this responsibility to Nginx, and using Django
# solely for backend functionality.
# REACT_APP_DIR = os.path.join(BASE_DIR, 'frontend/build')

# Directory where Django will store collected static files.
# This application doesn't store static files, as they are
# passed from the front end to the backend as blobs. A blob is
# essentially binary data that is only temporarily stored in memory
# for encrypting and decrypting, and is not stored on the server.
# It was only added here because Django gets angry if it's not there.
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Logging added for spotting AWS RDS connection issues and other
# potential problems during the deployment process.
LOGGING = {
    'version': 1,
    'handlers': {
        'console': { 
            'level': 'DEBUG',
            'class': 'logging.StreamHandler', 
        },
    },
    'loggers': {
        'django': { 
            'handlers': ['console'], 
            'level': 'DEBUG',
            'propagate': True, 
        },
    },
}


### File: ./backend/urls.py

from django.urls import path, include, re_path
from views import index

urlpatterns = [
    path('api/', include('core.urls')),  # Prefix all your API URLs with 'api/'
    path('', index, name='index'), 
]


### File: ./backend/views.py

# encrypted-file-transfer/backend/views.py

from django.shortcuts import render
from django.http import HttpResponse
from django.conf import settings
import os
from django.views.decorators.csrf import csrf_exempt

@csrf_exempt
def index(request):
  try:
    with open(os.path.join(settings.REACT_APP_DIR, 'index.html')) as f:
      return HttpResponse(f.read())
  except FileNotFoundError:
    return HttpResponse(
      """
      This URL is only accessible after you've built the React frontend.
      """,
      status=501,
    )


### File: ./backend/wsgi.py

print("WSGI file loaded")
"""
WSGI config for project.

It exposes the WSGI callable as a module-level variable named ``application``.
"""

import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'settings')

application = get_wsgi_application()

### File: ./backend/__init__.py



### File: ./backend/core/admin.py

from django.contrib import admin

# Register your models here.


### File: ./backend/core/apps.py

from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"


### File: ./backend/core/crypto_utils.py

# encrypted-file-transfer/backend/core/crypto_utils.py

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import padding as sym_padding
from cryptography.hazmat.backends import default_backend
import os

def generate_key_iv():
    """
    Generates a new AES-256 key and IV.
    """
    key = os.urandom(32)  # AES-256 key
    iv = os.urandom(16)  # AES block size is 128 bits
    return key, iv

def encrypt_aes(data, key, iv):
    """
    Encrypts data using AES-256-CBC.
    """
    padder = sym_padding.PKCS7(128).padder()
    padded_data = padder.update(data) + padder.finalize()
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()
    return encryptor.update(padded_data) + encryptor.finalize()

def decrypt_aes(data, key, iv):
    """
    Decrypts data using AES-256-CBC.
    """
    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(data) + decryptor.finalize()
    unpadder = sym_padding.PKCS7(128).unpadder()
    return unpadder.update(decrypted_data) + unpadder.finalize()

### File: ./backend/core/models.py

# encrypted-file-transfer/backend/core/models.py

from django.db import models
import uuid

class EncryptedFile(models.Model):
    id = models.AutoField(primary_key=True)
    uuid = models.UUIDField(default=uuid.uuid4, editable=False)
    key = models.BinaryField()
    iv = models.BinaryField()

### File: ./backend/core/tests.py

from django.test import TestCase

# Create your tests here.


### File: ./backend/core/urls.py

# encrypted-file-transfer/backend/core/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('process_file/', views.file_process_view, name='file_process_view'),
    path('test/', views.test_endpoint, name='test_endpoint'),
]

### File: ./backend/core/views.py

from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from .crypto_utils import encrypt_aes, decrypt_aes, generate_key_iv
from .models import EncryptedFile
import uuid
import base64
import logging

logger = logging.getLogger(__name__)

@csrf_exempt
def test_endpoint(request):
    return JsonResponse({"message": "Test endpoint working!"})

@csrf_exempt
def file_process_view(request):
    try:
        if request.method == 'POST' and request.FILES:
            file = request.FILES['file']
            action = request.POST.get('action', '')

            logger.info(f"Processing file for action: {action}")

            if action == 'encrypt':
                key, iv = generate_key_iv()
                encrypted_data = encrypt_aes(file.read(), key, iv)
                file_uuid = uuid.uuid4()
                EncryptedFile.objects.create(uuid=file_uuid, key=key, iv=iv)
                encoded_data = base64.b64encode(encrypted_data).decode('utf-8')
                logger.info(f"File encrypted successfully with UUID: {file_uuid}")
                return JsonResponse({'uuid': str(file_uuid), 'encrypted_file': encoded_data, 'file_name': file.name + '.enc'})

            elif action == 'decrypt':
                file_uuid = uuid.UUID(request.POST.get('uuid', ''))
                encrypted_file = EncryptedFile.objects.get(uuid=file_uuid)
                decrypted_data = decrypt_aes(file.read(), encrypted_file.key, encrypted_file.iv)
                encoded_data = base64.b64encode(decrypted_data).decode('utf-8')
                original_file_name = file.name.rsplit('.enc', 1)[0]
                logger.info(f"File decrypted successfully for UUID: {file_uuid}")
                return JsonResponse({'decrypted_file': encoded_data, 'original_name': original_file_name})

        return HttpResponse('Invalid request', status=400)
    except Exception as e:
        logger.error(f"Error processing file: {e}", exc_info=True)
        return HttpResponse('Server Error', status=500)

### File: ./backend/core/__init__.py



### File: ./backend/core/migrations/0001_initial.py

# Generated by Django 5.0.3 on 2024-03-10 03:53

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='EncryptedFile',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('uuid', models.UUIDField(default=uuid.uuid4, editable=False)),
                ('key', models.BinaryField()),
                ('iv', models.BinaryField()),
            ],
        ),
    ]


### File: ./backend/core/migrations/__init__.py



### File: ./frontend/public/index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>


### File: ./frontend/src/App.css

/* App.css */
.App {
  text-align: center;
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  font-size: calc(10px + 2vmin);
  color: white;
  padding-top: 50px;
}

.App-header {
  background-color: #404040;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
  margin: 20px 0;
  width: 80%;
  max-width: 600px;
}

input[type="file"] {
  margin: 10px 0;
}

.uuid-box {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 10px;
  margin: 15px;
}

.radio-btn {
  font-size: 0.44em;
}

button {
  background-color: #1d9e33;
  border: none;
  border-radius: 5px;
  padding: 10px 20px;
  color: #fff;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:hover {
  background-color: #51df68;
}

.submit-button-container {
  display: flex;
  justify-content: center;
  margin-top: 10px;
}

.uuid-input-container {
  text-align: center;
  margin-top: 20px;
}

.tips-title {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

.tips-section {
  background-color: #404040;
  padding: 20px;
  border-radius: 10px;
  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);
  margin: 20px 0;
  width: 80%;
  max-width: 600px;
  color: #ccc;
  text-align: left;
  font-size: 0.5em;
}

.tips-section ol {
  counter-reset: list-counter;
  list-style-type: none;
  padding-left: 20px;
}

.tips-section ol li {
  counter-increment: list-counter;
  margin-bottom: 10px;
}

.tips-section ol li::before {
  content: counter(list-counter) ". ";
  font-weight: bold;
  margin-right: 5px;
}

.tips-section p {
  margin-bottom: 20px;
  font-weight: bold;
}


### File: ./frontend/src/App.js

// encrypted-file-transfer/frontend/src/App.js
// Frontend for the AES-256 CBC File Encryption project
// This file contains the main React component for the frontend
// It allows users to select a file, choose an action (encrypt or decrypt),
// and submit the file for processing. It does this by sending a POST request
// to the backend API, which processes the file and returns the result.

import React, { useState } from 'react';
import './App.css';

function App() {
  const [file, setFile] = useState(null);
  const [action, setAction] = useState('');
  const [uuid, setUuid] = useState('');
  const [downloadLink, setDownloadLink] = useState('');
  const [fileName, setFileName] = useState('');
  const apiBaseUrl = 'api/';

  const handleFileChange = (event) => {
    setFile(event.target.files[0]);
    if (action === 'decrypt') {
      setFileName(event.target.files[0].name.replace('.enc', ''));
    } else {
      setFileName(event.target.files[0].name + '.enc');
    }
  };

  const handleActionChange = (event) => {
    setAction(event.target.value);
    if (event.target.value === 'decrypt' && uuid) {
      setDownloadLink('');
    }
  };

  const handleUUIDChange = (event) => {
    setUuid(event.target.value);
  };

  // Event handler for the submit button.
  // Checks whether a file and action have been selected
  // for encryption or decryption.
  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!file || !action) {
      alert('Please select a file and an action!');
      return;
    }

    // If the file and action have been chosen,
    // 
    const formData = new FormData();
    formData.append('file', file);
    formData.append('action', action);
    if (action === 'decrypt') {
      formData.append('uuid', uuid);
    }

    
    try {
      const response = await fetch(`${apiBaseUrl}/process_file/`, {
        method: 'POST',
        body: formData,
      });

      if (response.ok) {
        const data = await response.json();
        if (action === 'encrypt') {
          setUuid(data.uuid); // Set UUID for possible decryption later
        } else {
          setFileName(data.original_name); // Set the original file name for the download
        }
        const downloadBlob = new Blob([Uint8Array.from(atob(data.encrypted_file || data.decrypted_file), c => c.charCodeAt(0))], { type: 'application/octet-stream' });
        setDownloadLink(URL.createObjectURL(downloadBlob));
      } else {
        alert('Failed to process file.');
      }
    } catch (error) {
      console.error('Error processing file:', error);
      alert('Error processing file.');
    }
  };

  // This section dictates the HTML for the frontend. It includes
  // the file input, action selection, submit button, UUID input,
  // and download link for the encrypted or decrypted file.
  // It could also be thought of as being the entry point for the
  // frontend application, as it is the main component rendered by
  // the React application.

  // If we would like to change the styling up for our applications,
  // then we would need to modify the CSS file 'App.css' in the same
  // directory as this file, and that would link up with the HTML found
  // in this section. HTML is for the structure of the page, CSS is for
  // the styling, and JavaScript (React-JS in this case) is for the interactivity.
  // The JS code in this file is found above in the 'App' function.
  return (
    <div className="App">
      <header className="App-header">
        <p>AES-256 CBC File Encryption</p>
        <div className="inline-container">
          <input type="file" onChange={handleFileChange} />
          <div>
            <label className="radio-btn">
              <input type="radio" value="encrypt" checked={action === 'encrypt'} onChange={handleActionChange} /> Encrypt
            </label>
            <label className="radio-btn">
              <input type="radio" value="decrypt" checked={action === 'decrypt'} onChange={handleActionChange} /> Decrypt
            </label>
          </div>
        </div>
        <div className="submit-button-container">
          <button onClick={handleSubmit}>Submit</button>
        </div>
      </header>
      <div className="uuid-input-container">
        <input
          type="text"
          placeholder="Enter UUID for Decryption"
          value={uuid}
          onChange={handleUUIDChange}
        />
      </div>
      {downloadLink && (
        <a href={downloadLink} download={fileName}>Download {action === 'encrypt' ? 'Encrypted' : 'Decrypted'} File</a>
      )}
      <div className="tips-section">
        <p className="tips-title">How to Use</p>
        <ol>
          <li>Choose file to encrypt or decrypt.</li>
          <li>Click 'Encrypt' or 'Decrypt' and 'Submit'.</li>
          <li>For decryption, enter the UUID generated during encryption.</li>
          <li>Download the resulting file.</li>
        </ol>
      </div>
    </div>
  );
}

export default App;


### File: ./frontend/src/App.test.js

import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


### File: ./frontend/src/index.css

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.UUID-label {
  font-size: 0.5em;
  margin: 10px;
}

.inline-container {
  display: flex;
  align-items: center;
  margin: 0px;
  padding: 0px;
}

input[type="file"] {
  flex-grow: 0;
}

.inline-container > div {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#uuidInput {
  width: 100%;
  padding: 12px 20px;
  margin: 8px 0;
  display: inline-block;
  border: 1px solid #ccc;
  border-radius: 4px;
  box-sizing: border-box;
  text-align: center;
}

### File: ./frontend/src/index.js

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


### File: ./frontend/src/reportWebVitals.js

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


### File: ./frontend/src/setupTests.js

// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


